# ğŸ“Œ Problem Statement â€” Production-Ready Sorting System

You are building a **production-ready student ranking module** for an academic platform.

You are given a list of `Student` objects.  
Each `Student` contains the following fields:

- **id** *(integer)* â€” unique student identifier
- **name** *(string)* â€” student name
- **score** *(integer)* â€” marks obtained by the student
- **age** *(integer)* â€” age of the student

---

## ğŸ¯ Objective

Design and implement a **robust, maintainable, and production-ready sorting mechanism** 
that sorts students based on **multiple business rules**, while keeping the code **clean, 
extensible, and readable**.

---

## ğŸ“ Sorting Rules (Business Logic)

The students must be sorted using the following priority order:

### ğŸ”¹ Priority 1 â€” Score
- Sort by **score in descending order** (higher score first)

### ğŸ”¹ Priority 2 â€” Age (tie-breaker 1)
- If scores are equal, sort by **age in ascending order** (younger student first)

### ğŸ”¹ Priority 3 â€” Name (tie-breaker 2)
- If both score and age are equal, sort by **name in ascending alphabetical order**

---

## ğŸ“¤ Final Output Requirement

- Return a **list of student names only**
- Names must appear **exactly in the sorted order**

---

## ğŸ“¥ Example Input

```java
[
  (1, "Alice", 90, 22),
  (2, "Bob", 90, 21),
  (3, "Charlie", 85, 23),
  (4, "David", 90, 21)
]
```
# ğŸ“¤ Expected Output
```java
["Bob", "David", "Alice", "Charlie"]
```

# ğŸ›  Constraints

- 1 â‰¤ number of students â‰¤ N

- Student names are non-null and non-empty

- Scores and ages are non-negative integers

- Sorting must be:

  - Stable

  - Deterministic

  - Thread-safe if reused

- No modification of the original list unless explicitly documented

# ğŸ’¡ Expected Production-Ready Approaches

- You may use any ONE of the following approaches, but it must be clean and maintainable:

- Java Streams API with comparator chaining

- Comparator.comparing() with method references

- Custom Comparator class (preferred for large systems)

- Comparable (only if this is the natural/default ordering)

# ğŸ§  Key Concepts Being Tested

Multi-level sorting (3+ keys)

Comparator chaining vs Comparable

Clean API design

Separation of concerns

Readability and maintainability

Avoiding magic logic inside lambdas

Production-quality thinking (not just â€œit worksâ€)

# ğŸš« What to Avoid (Production Red Flags)

Hard-coded comparison logic scattered across methods

Returning inconsistent comparison results

Mixing sorting logic with data transformation

Mutating input lists without documentation

Over-complex lambdas that reduce readability